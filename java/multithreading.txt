Multithreading 
---------------------
Multithreading in Java is a process of executing multiple threads simultaneously.

 
Advantages of Java Multithreading
-----------------------------------
Advantages of Java Multithreading
1) It doesn't block the user because threads are independent and you can perform multiple operations at the same time.

2) You can perform many operations together, so it saves time.

3) Threads are independent, so it doesn't affect other threads if an exception occurs in a single thread.

Multitasking
--------------
Multitasking is a process of executing multiple tasks simultaneously. We use multitasking to utilize the CPU. Multitasking can be achieved in two ways:

1) Process-based Multitasking (Multiprocessing)
Each process has an address in memory. In other words, each process allocates a separate memory area.
A process is heavyweight.
Cost of communication between the process is high.
Switching from one process to another requires some time for saving and loading registers, memory maps, updating lists, etc.
2) Thread-based Multitasking (Multithreading)
Threads share the same address space.
A thread is lightweight.
Cost of communication between the thread is low.


Thread in java
--------------
A thread is a lightweight sub-process, the smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking.
However, we use multithreading than multiprocessing because threads use a shared memory area.
 They don't allocate separate memory area so saves memory, and context-switching between the threads takes less time than process.
 
Thread class methods
--------------------
   Modifier and Type    Method     Description
   -----------------    ------     -----------

1)	void	            start()	        It is used to start the execution of the thread.
2)	void	             run()	        It is used to do an action for a thread.
3)	static void	        sleep()	        It sleeps a thread for the specified amount of time.
4)	static Thread	 currentThread()	It returns a reference to the currently executing thread object.
5)	void	            join()      	It waits for a thread to die.
6)	int	             getPriority()	    It returns the priority of the thread.
7)	void	         setPriority()	    It changes the priority of the thread.
8)	String	           getName()	    It returns the name of the thread.
9)	void	           setName()	    It changes the name of the thread.
10)	long             	getId()     	It returns the id of the thread.
11)	boolean	            isAlive()	    It tests if the thread is alive.
12)	static void	         yield()       	It causes the currently executing thread object to pause and allow other threads to execute temporarily.
13)	void	            suspend()     	It is used to suspend the thread.
14)	void	            resume()    	It is used to resume the suspended thread.
15)	void	             stop()	        It is used to stop the thread.
16)	void	           destroy()	    It is used to destroy the thread group and all of its subgroups.
17)	boolean	           isDaemon()	    It tests if the thread is a daemon thread.
18)	void	           setDaemon()	    It marks the thread as daemon or user thread.
19)	void	           interrupt()  	It interrupts the thread.
20)	boolean	         isinterrupted()	It tests whether the thread has been interrupted.
21)	static boolean	  interrupted()	    It tests whether the current thread has been interrupted.
22)	static int	       activeCount()	It returns the number of active threads in the current thread's thread group.
23)	void	           checkAccess()	It determines if the currently running thread has permission to modify the thread.
24)	static boolean	    holdLock()	    It returns true if and only if the current thread holds the monitor lock on the specified object.
25)	static void	        dumpStack()	    It is used to print a stack trace of the current thread to the standard error stream.
26)	StackTraceElement[]	getStackTrace()	It returns an array of stack trace elements representing the stack dump of the thread.
27)	static int	       enumerate()	    It is used to copy every active thread's thread group and its subgroup into the specified array.
28)	Thread.State	    getState()	    It is used to return the state of the thread.
29)	ThreadGroup	    getThreadGroup()	It is used to return the thread group to which this thread belongs
30)	String	           toString()	    It is used to return a string representation of this thread, including the thread's name, priority, and thread group.
31)	void	             notify()	    It is used to give the notification for only one thread which is waiting for a particular object.
32)	void	           notifyAll()	    It is used to give the notification to all waiting threads of a particular object.
33)	void	setContextClassLoader()	    It sets the context ClassLoader for the Thread.
34)	ClassLoader	getContextClassLoader()	It returns the context ClassLoader for the thread.
35)	static -- Thread.UncaughtExceptionHandle -- getDefaultUncaughtExceptionHandler()--It returns the default handler invoked when a thread abruptly terminates due to an uncaught exception.
36)	static void -- setDefaultUncaughtExceptionHandler() --	It sets the default handler invoked when a thread abruptly terminates due to an uncaught exception.



Life cycle of a Thread (Thread States)
--------------------------------------------

New 
  - The thread is in new state if you create an instance of Thread class but before the invocation of start() method.
Runnable
  - The thread is in runnable state after invocation of start() method, but the thread scheduler has not selected it to be the running thread.
Running
  - The thread is in running state if the thread scheduler has selected it.
Non-Runnable (Blocked)
  - This is the state when the thread is still alive, but is currently not eligible to run.
Terminated
  - A thread is in terminated or dead state when its run() method exits.
  
There are two ways to create a thread:

1.By extending Thread class
2.By implementing Runnable interface.


Thread class:
-------------
Thread class provide constructors and methods to create and perform operations on a thread.Thread class extends Object class and implements Runnable interface.

Commonly used Constructors of Thread class:
----------------------------------------------
1.Thread()
2.Thread(String name)
3.Thread(Runnable r)
4.Thread(Runnable r,String name)

Commonly used methods of Thread class
---------------------------------------
6.public void run(): is used to perform action for a thread.
7.public void start(): starts the execution of the thread.JVM calls the run() method on the thread.
8.public void sleep(long miliseconds): Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds.
9.public void join(): waits for a thread to die.
10.public void join(long miliseconds): waits for a thread to die for the specified miliseconds.
11.public int getPriority(): returns the priority of the thread.
12.public int setPriority(int priority): changes the priority of the thread.
13.public String getName(): returns the name of the thread.
14.public void setName(String name): changes the name of the thread.
15.public Thread currentThread(): returns the reference of currently executing thread.
16.public int getId(): returns the id of the thread.
17.public Thread.State getState(): returns the state of the thread.
18.public boolean isAlive(): tests if the thread is alive.
19.public void yield(): causes the currently executing thread object to temporarily pause and allow other threads to execute.
20.public void suspend(): is used to suspend the thread(depricated).
21.public void resume(): is used to resume the suspended thread(depricated).
22.public void stop(): is used to stop the thread(depricated).
23.public boolean isDaemon(): tests if the thread is a daemon thread.
24.public void setDaemon(boolean b): marks the thread as daemon or user thread.
25.public void interrupt(): interrupts the thread.
26.public boolean isInterrupted(): tests if the thread has been interrupted.
27.public static boolean interrupted(): tests if the current thread has been interrupted.

** example in workspace.


Runnable interface:
----------------------
The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread.
 Runnable interface have only one method named run().
 public void run(): is used to perform action for a thread.
 
Thread Priority
-----------------
public static int MIN_PRIORITY
public static int NORM_PRIORITY
public static int MAX_PRIORITY

Default priority of a thread is 5 (NORM_PRIORITY). The value of MIN_PRIORITY is 1 and the value of MAX_PRIORITY is 10.

ex: 
m1.setPriority(Thread.MIN_PRIORITY);  
m2.setPriority(Thread.MAX_PRIORITY);  



Daemon Thread
-----------------
Daemon thread in java is a service provider thread that provides services to the user thread. 
Its life depend on the mercy of user threads i.e. when all the user threads dies, JVM terminates this thread automatically.

-It provides services to user threads for background supporting tasks. It has no role in life than to serve user threads.
-Its life depends on user threads.
-It is a low priority thread.
-JVM terminates the daemon thread if there is no user thread

Methods for Java Daemon thread by Thread class
------------------------------------------------
1.public void setDaemon(boolean status)
2.public boolean isDaemon()

ex:  TestDaemonThread1 t1=new TestDaemonThread1();//creating thread  
     t1.setDaemon(true);//now t1 is daemon thread  
    
     t1.start();//starting threads 
  **If you want to make a user thread as Daemon, it must not be started otherwise it will throw IllegalThreadStateException.
   t1.start();  
  t1.setDaemon(true);//will throw exception here
  
Thread Pool
--------------
-Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times.
-In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. 
 After completion of the job, thread is contained in the thread pool again.
- java.util.concurrent.Executors provide factory and support methods for java.util.concurrent.Executor interface to create the thread pool in java.
- Executors is a utility class that also provides useful methods to work with ExecutorService,
 ScheduledExecutorService, ThreadFactory, and Callable classes through various factory methods.
 
 
 ThreadGroup
 ----------------
- Java provides a convenient way to group multiple threads in a single object. In such way, we can suspend, resume or interrupt group of threads by a single method call.
- Java thread group is implemented by java.lang.ThreadGroup class.

ex: Thread.currentThread().getThreadGroup().interrupt();  
  Constrictors
  ------------
     - ThreadGroup(String name)
	 - ThreadGroup(ThreadGroup parent, String name)
  Methods
  -------
S.N.	 Modifier and Type	        Method	                                     Description
1)	void	                      checkAccess()	           This method determines if the currently running thread has permission to modify the thread group.
2)	int	                          activeCount()	           This method returns an estimate of the number of active threads in the thread group and its subgroups.
3)	int	                          activeGroupCount()	   This method returns an estimate of the number of active groups in the thread group and its subgroups.
4)	void	                      destroy()             	This method destroys the thread group and all of its subgroups.
5)	int	                          enumerate(Thread[] list)	This method copies into the specified array every active thread in the thread group and its subgroups.
6)	int	                          getMaxPriority()	        This method returns the maximum priority of the thread group.
7)	String	                        getName()	           This method returns the name of the thread group.
8)	ThreadGroup	                  getParent()	          This method returns the parent of the thread group.
9)	void	                      interrupt()	          This method interrupts all threads in the thread group.
10)	boolean	                      isDaemon()	          This method tests if the thread group is a daemon thread group.
11)	void	                      setDaemon(boolean daemon)  	This method changes the daemon status of the thread group.
12)	boolean	                      isDestroyed()              	This method tests if this thread group has been destroyed.
13)	void	                      list()	                    This method prints information about the thread group to the standard output.
14)	boolean	                      parentOf(ThreadGroup g	    This method tests if the thread group is either the thread group argument or one of its ancestor thread groups.
15)	void	                      suspend()	             This method is used to suspend all threads in the thread group.
16)	void	                      resume()	            This method is used to resume all threads in the thread group which was suspended using suspend() method.
17)	void	                      setMaxPriority(int pri)	This method sets the maximum priority of the group.
18)	void	                      stop()	               This method is used to stop all threads in the thread group.
19)	String	                      toString()	           This method returns a string representation of the Thread group.

*****Java Shutdown Hook

Garbeg collector 
----------------
garbage means unreferenced objects.

 ways:

1.By nulling the reference: 
Employee e=new Employee();  
e=null;

2.By assigning a reference to another:
Employee e1=new Employee();  
Employee e2=new Employee();  
e1=e2;

3) By anonymous object:
new Employee(); 

4.finalize() method
The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing. 
This method is defined in Object class as: protected void finalize(){}

5.The gc() method is used to invoke the garbage collector to perform cleanup processing.
 The gc() is found in System and Runtime classes.public static void gc(){}  


****Java Runtime class




Synchronization
-------------------
Synchronization in java is the capability to control the access of multiple threads to any shared resource.
Java Synchronization is better option where we want to allow only one thread to access the shared resource at a time.
   -To prevent thread interference.
   -To prevent consistency problem.
   
two types of synchronization
-------------------------------
Process Synchronization
Thread Synchronization

- There are two types of thread synchronization mutual exclusive and inter-thread communication(Cooperation).

-Mutual Exclusive
-------------------
Synchronized method.
Synchronized block.
static synchronization.


synchronized method
-------------------------
If you declare any method as synchronized, it is known as synchronized method.

Synchronized method is used to lock an object for any shared resource.

When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task.

ex:

 synchronized void printTable(int n){//synchronized method  
   for(int i=1;i<=5;i++){  
     System.out.println(n*i);  
     try{  
      Thread.sleep(400);  
     }catch(Exception e){System.out.println(e);}  
   }   
 }  


Synchronized block
----------------------------
Synchronized block is used to lock an object for any shared resource.
Scope of synchronized block is smaller than the method.

syntax:
synchronized (object reference expression) {   
  //code block   
}

Static Synchronization
If you make any static method as synchronized, the lock will be on the class not on object.

Problem without static synchronization
Suppose there are two objects of a shared class(e.g. Table) named object1 and object2.In case of synchronized method and synchronized block there 
cannot be interference between t1 and t2 or t3 and t4 because t1 and t2 both refers to a common object that have a single lock.
But there can be interference between t1 and t3 or t2 and t4 because t1 acquires another lock and t3 acquires another lock.
I want no interference between t1 and t3 or t2 and t4.Static synchronization solves this problem.


Deadlock in java
Deadlock in java is a part of multithreading. Deadlock can occur in a situation when a thread is waiting for an object lock,
 that is acquired by another thread and second thread is waiting for an object lock that is acquired by first thread. 
Since, both threads are waiting for each other to release the lock, the condition is called deadlock

Inter-thread communication 
---------------------------
allowing synchronized threads to communicate with each other.
implemented by following methods of Object class:

1.wait()
    - Causes current thread to release the lock and wait until either another thread invokes the notify() method or the notifyAll() method for this object, 
	  or a specified amount of time has elapsed.
	  -public final void wait()throws InterruptedException	---- waits until object is notified.
      -public final void wait(long timeout)throws InterruptedException ----	waits for the specified amount of time.
2.notify()
    - Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. Syntax:
    - public final void notify()
3.notifyAll()
    - Wakes up all threads that are waiting on this object's monitor. Syntax:
    - public final void notifyAll()
	
The 3 methods provided by the Thread class for interrupting a thread
public void interrupt()
public static boolean interrupted()
public boolean isInterrupted()










