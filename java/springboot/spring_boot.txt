Spring Boot
**********************************

- Spring Boot is a Spring module that provides the RAD (Rapid Application Development) feature to the Spring framework.
- Spring Boot is a project that is built on the top of the Spring Framework. It provides an easier and faster way to set up, configure, and run both simple and web-based applications
  (RESTfull services)/ not ui...
- In short, Spring Boot is the combination of Spring Framework and Embedded Servers.
- In Spring Boot, there is no requirement for XML configuration (deployment descriptor). 
   It uses framework to reduce configurations (convention over configuration software design paradigm) that means it decreases the effort of the developer.
   
Why Spring Boot Framework?

-The dependency injection approach is used in Spring Boot.
-It contains powerful database transaction management capabilities.
-It simplifies integration with other Java frameworks like JPA/Hibernate ORM, Struts, etc.
-It reduces the cost and development time of the application.

Spring sister projects are as follows:

-Spring Data: It simplifies data access from the relational and NoSQL databases.
-Spring Batch: It provides powerful batch processing.
-Spring Security: It is a security framework that provides robust security to applications.
-Spring Social: It supports integration with social networking like LinkedIn.
-Spring Integration: It is an implementation of Enterprise Integration Patterns. 
  It facilitates integration with other enterprise applications using lightweight messaging and declarative adapters.
  
Advantages of Spring Boot
- It creates stand-alone Spring applications that can be started using Java -jar.
- It tests web applications easily with the help of different Embedded HTTP servers such as Tomcat, Jetty, etc. We don't need to deploy WAR files.
- It provides opinionated 'starter' POMs to simplify our Maven configuration.
- It provides production-ready features such as metrics, health checks, and externalized configuration.
- There is no requirement for XML configuration.
- It offers a CLI tool for developing and testing the Spring Boot application.
- It offers the number of plug-ins.
- It also minimizes writing multiple boilerplate codes (the code that has to be included in many places with little or no alteration), XML configuration, and annotations.
- It increases productivity and reduces development time.

Limitations of Spring Boot
- Spring Boot can use dependencies that are not going to be used in the application. These dependencies increase the size of the application.

Goals of Spring Boot
- The main goal of Spring Boot is to reduce development, unit test, and integration test time.

- Provides Opinionated Development approach
- Avoids defining more Annotation Configuration
- Avoids writing lots of import statements
- Avoids XML Configuration.



spring vs spring Boot vs Spring MVC  : check the snap
**************************************


There are four layers in Spring Boot 
- Spring Boot follows a layered architecture in which each layer communicates with the layer directly below or above (hierarchical structure) it.
 1.Presentation Layer
      - The presentation layer handles the HTTP requests, 
	    translates the JSON parameter to object, and authenticates the request and transfer it to the business layer. In short, it consists of views i.e., frontend part.
 2.Business Layer(service,controller)
      - The business layer handles all the business logic. It consists of service classes and uses services provided by data access layers. 
	    It also performs authorization and validation.
 3.Persistence Layer(model(ex:the dao))
      - The persistence layer contains all the storage logic and translates business objects from and to database rows.
 4.Database Layer(data base(ex: sql,oracle))
      - In the database layer, CRUD (create, retrieve, update, delete) operations are performed.


Spring Initializr
********************
web-based tool provided by the Pivotal Web Service(sb frame work).

Spring Initializr Modules
----------------------------
initializr-actuator: It provides additional information and statistics on project generation. It is an optional module.
initializr-bom: In this module, BOM stands for Bill Of Materials. In Spring Boot, BOM is a special kind of POM that is used to control the versions of a project's dependencies. It provides a central place to define and update those versions. It provides flexibility to add a dependency in our module without worrying about the versions.
Outside the software world, the BOM is a list of parts, items, assemblies, and other materials required to create products. It explains what, how, and where to collect required materials.
initializr-docs: It provides documentation.
initializr-generator: It is a core project generation library.
initializr-generator-spring:
initializr-generator-test: It provides a test infrastructure for project generation.
initializr-metadata: It provides metadata infrastructure for various aspects of the projects.
initializr-service-example: It provides custom instances.
initializr-version-resolver: It is an optional module to extract version numbers from an arbitrary POM.
initializr-web: It provides web endpoints for third party clients.

Spring Annotations
------------------------
- Spring Annotations is a form of metadata that provides data about a program.annotations are used to provide supplemental information about a program.

@Required: 
     applies to the bean setter method. 
	 must be populated at configuration time with the required property 
	 exception BeanInitilizationException.

@Autowired:
     When we use @Autowired annotation, the spring container auto-wires the bean by matching data-type.
	 
@Configuration: 
     a class-level annotation. The class annotated with @Configuration used by Spring Containers as a source of bean definitions.
	 
@ComponentScan:
     to scan a package for beans.
	 used with the annotation @Configuration
	 We can also specify the base packages to scan for Spring Components.
	 
@Bean: 
     method-level annotation.
	 It is an alternative of XML <bean> tag. 
	 tells the method to produce a bean to be managed by Spring Container.
	 
@Component:
      class-level annotation.
	  used to mark a Java class as a bean. 
	  A Java class annotated with @Component is found during the classpath.
	  Framework pick it up and configure it in the application context as a Spring Bean.
	  
@Controller: 
      class-level annotation. 
	   It is a specialization of @Component
	   It marks a class as a web request handler. 
	   often used to serve web pages. By default, it returns a string that indicates which route to redirect.
	   mostly used with @RequestMapping annotation.
@Service: 
      class level.
	  It tells the Spring that class contains the business logic.
@Repository: 
      class-level annotation.
	  The repository is a DAOs (Data Access Object) that access the database directly.
	  The repository does all the operations related to the database.
	  
Spring Boot Annotations
------------------------

@EnableAutoConfiguration:
     auto-configures the bean that is present in the classpath and configures it to run the methods. 
	 alternative of the annotation, i.e. @SpringBootApplication.
	 
@SpringBootApplication: It is a combination of three annotations @EnableAutoConfiguration, @ComponentScan, and @Configuration.

Spring MVC and REST Annotations
--------------------------------
@RequestMapping: 
     It is used to map the web requests.
	 It has many optional elements like consumes, header, method, name, params, path, produces, and value. We use it with the class as well as the method.
@GetMapping:
      It maps the HTTP GET requests on the specific handler method.
	  to create a web service endpoint that fetches
	  used instead of using: @RequestMapping(method = RequestMethod.GET)
@PostMapping:
      It maps the HTTP POST requests on the specific handler method. 
	  to create a web service endpoint that creates
	  used instead of using: @RequestMapping(method = RequestMethod.POST)
@PutMapping:
     It maps the HTTP PUT requests on the specific handler method
	 to create a web service endpoint that creates or updates
	 used instead of using: @RequestMapping(method = RequestMethod.PUT)
@DeleteMapping:
     It maps the HTTP DELETE requests on the specific handler method. 
	 It is used to create a web service endpoint that deletes a resource.
	 It is used instead of using: @RequestMapping(method = RequestMethod.DELETE)
@PatchMapping:
      It maps the HTTP PATCH requests on the specific handler method.
	  It is used instead of using: @RequestMapping(method = RequestMethod.PATCH)
@RequestBody: 
      used to bind HTTP request with an object in a method parameter. 
	  Internally it uses HTTP MessageConverters to convert the body of the request. 
	  When we annotate a method parameter with @RequestBody, the Spring framework binds the incoming HTTP request body to that parameter.
@ResponseBody: 
      binds the method return value to the response body.
	  It tells the Spring Boot Framework to serialize a return an object into JSON and XML format.
@PathVariable: 
      used to extract the values from the URI. 
	  most suitable for the RESTful web service, where the URL contains a path variable.
	  We can define multiple @PathVariable in a method.
@RequestParam:
      used to extract the query parameters form the URL.also known as a query parameter. 
	  most suitable for web applications. It can specify default values if the query parameter is not present in the URL.	
@RequestHeader: 
       used to get the details about the HTTP request headers.
	   as a method parameter. 
	   The optional elements of the annotation are name, required, value, defaultValue. For each detail in the header, we should specify separate annotations. We can use it multiple time in a method
@RestController:
       can be considered as a combination of @Controller and @ResponseBody annotations. 
	   @RestController annotation is itself annotated with the @ResponseBody annotation. It eliminates the need for annotating each method with @ResponseBody.
	   
@RequestAttribute: 
      It binds a method parameter to request attribute. It provides convenient access to the request attributes from a controller method.
      With the help of @RequestAttribute annotation, we can access objects that are populated on the server-side.




Spring Boot Dependancy
------------------------

Each release of Spring Boot provides a list of dependencies(supporting versons of pom jars) that it supports.
 (if we define BOM verson, we dont necessrily need to define version of each jar. spring auto meticaly picks suitable version.even if we do define version, it ignores the <version> tag for that dependencies.)
The list of dependencies(versions) is available as a part of the Bills of Materials - BOM (spring-boot-dependencies) that can be used with Maven. 
ex:


Maven project inherits the following features from spring-boot-starter-parent:

- The default Java compiler version
- UTF-8 source encoding
- It inherits a Dependency Section from the spring-boot-dependency-pom. It manages the version of common dependencies. It ignores the <version> tag for that dependencies.
- Sensible resource filtering
- Sensible plugin configuration



- Defining BOM:

<parent>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-parent</artifactId>  
<version>2.2.2.BUILD-SNAPSHOT</version>      <!-- lookup parent from repository -->  
<relativePath/>   
</parent>  


- Changing the Java version:

<properties>    
<java.version>1.8</java.version>    
</properties>

- Adding Spring Boot Maven Plugin

<build>    
<plugins>    
<plugin>    
<groupId>org.springframework.boot</groupId>    
<artifactId>spring-boot-maven-plugin</artifactId>    
</plugin>    
</plugins>    
</build>    


- Spring Boot without Parent POM
If we don't want to use spring-boot starter-parent dependency, but still want to take the advantage of the dependency management, we can use <scope> tag, as follows:

<dependencyManagement>  
<dependencies>  
<dependency><!-- Import dependency management from Spring Boot -->  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-dependencies</artifactId>  
<version>2.2.2.RELEASE</version>  
<type>pom</type>  
<scope>import</scope>  
</dependency>  
</dependencies>  
</dependencyManagement>  


Spring Boot Application Properties
---------------------------------------
1. built-in mechanism for application configuration using a file called application.properties.
- in src/main/resources
ex:
#configuring application name  
spring.application.name = demoApplication  
#configuring port  
server.port = 8081  

2.YAML Properties File
he Yaml file works because the Snake YAML jar is present in the classpath.
Instead of using the application.properties file, we can also use the application.yml file, but the Yml file should be present in the classpath.

ex:

spring:  
application:  
name: demoApplication  
server:  
port: 8081  


Spring Boot Starters
-----------------------
Spring Boot provides a number of starters that allow us to add jars in the classpath. Spring Boot built-in starters make development easier and rapid. Spring Boot Starters are the dependency descriptors.

all the starters follow a similar naming pattern: spring-boot-starter-*, where * denotes a particular type of application.
For example, if we want to use Spring and JPA for database access, we need to include the spring-boot-starter-data-jpa dependency in our pom.xml file of the project.
We can also include third party starters in our project. But we do not use spring-boot-starter for including third party dependency.
The third-party starter starts with the name of the project. For example, the third-party project name is abc, then the dependency name will be abc-spring-boot-starter.


Spring Boot Starter Parent:

- spring-boot-starter-parent is a project starter. It provides default configurations for our applications. It is used internally by all dependencies.
- All Spring Boot projects use spring-boot-starter-parent as a parent in pom.xml file.

<parent>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-parent</artifactId>  
<version>1.4.0.RELEASE</version>  
</parent>  

- 
Parent Poms allow us to manage the following things for multiple child projects and modules:

Configuration: It allows us to maintain consistency of Java Version and other related properties.
Dependency Management: It controls the versions of dependencies to avoid conflict.
Source encoding
Default Java Version
Resource filtering
It also controls the default plugin configuration.


Spring Boot Starter Parent Internal:
--------------------------------------------
Spring Boot Starter Parent defines spring-boot-dependencies as a parent pom. It inherits dependency management from spring-boot-dependencies.

<parent>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-dependencies</artifactId>  
<version>1.6.0.RELEASE</version>  
<relativePath>../../spring-boot-dependencies</relativePath>  
</parent>  

Default Parent Pom

<properties>  
<java.version>1.8</java.version>  
<resource.delimiter>@</resource.delimiter>   
<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>  
<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>  
<maven.compiler.source>${java.version}</maven.compiler.source>  
<maven.compiler.target>${java.version}</maven.compiler.target>  
</properties>  



Spring Boot Starter without Parent
In some cases, we need not to inherit spring-boot-starter-parent in the pom.xml file. To handle such use cases, Spring Boot provides the flexibility to still use the dependency management without inheriting the spring-boot-starter-parent.

<dependencyManagement>  
<dependencies>  
<dependency>  
<!-- Import dependency management from Spring Boot -->  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-dependencies</artifactId>  
<version>2.1.1.RELEASE</version>  
<type>pom</type>  
<scope>import</scope>  
</dependency>  
</dependencies>  
</dependencyManagement>  

Spring Boot Starter Web
--------------------------
1. to develop a web application
<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-web</artifactId>  
<version>2.2.2.RELEASE</version>  
</dependency>  

depends on:
org.springframework.boot:spring-boot-starter
org.springframework.boot:spring-boot-starter-tomcat
org.springframework.boot:spring-boot-starter-validation
com.fasterxml.jackson.core:jackson-databind
org.springframework:spring-web
org.springframework:spring-webmvc
By default, the spring-boot-starter-web contains the following tomcat server dependency:

<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-tomcat</artifactId>  
<version>2.0.0.RELEASE</version>  
<scope>compile</scope>  
</dependency>  

2.The spring-boot-starter-web auto-configures the following things that are required for the web development:

Dispatcher Servlet
Error Page
Web JARs for managing the static dependencies
Embedded servlet container



Spring Boot Embedded Web Server
---------------------------------

- default embedded server is Tomcat. 

Spring Boot also supports another two embedded servers:
Jetty Server
Undertow Server

- to add the Jetty server in the application, we need to add the spring-boot-starter-jetty dependency in our pom.xml file.
  make sure that the default Tomcat server is excluded from the spring-boot-starter-web. 
  <dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-web</artifactId>  
<exclusions>  
<exclusion>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-tomcat</artifactId>  
</exclusion>  
</exclusions>  
</dependency>  
<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-jetty</artifactId>  
</dependency>  

Undertow Server
---------------
- another server called Undertow.
It is written in Java and manage and sponsored by JBoss. 
make sure that the default Tomcat server is excluded from the spring-boot-starter-web.

The main advantages of Undertow server are:
Supports HTTP/2
HTTP upgrade support
Websocket Support
Provides support for Servlet 4.0
Flexible
Embeddable

<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-web</artifactId>  
<exclusions>  
<exclusion>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-tomcat</artifactId>  
</exclusion>  
</exclusions>  
</dependency>  
<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-undertow</artifactId>  
</dependency>  

spring-boot-starter-web vs. spring-boot-starter-tomcat
The spring-boot-starter-web contains the spring web dependencies that includes spring-boot-starter-tomcat. The spring-boot-starter-web contains the following:

spring-boot-starter
jackson
spring-core
spring-mvc
spring-boot-starter-tomcat
While the spring-boot-starter-tomcat contains everything related to Tomcat server.

core
el
logging
websocket
The starter-tomcat has the following dependencies:

<dependency>  
<groupId>org.apache.tomcat.embed</groupId>  
<artifactId>tomcat-embed-core</artifactId>  
<version>8.5.23</version>  
 <scope>compile</scope>  
</dependency>  
<dependency>  
<groupId>org.apache.tomcat.embed</groupId>  
<artifactId>tomcat-embed-el</artifactId>  
<version>8.5.23</version>  
<scope>compile</scope>  
</dependency>  
<dependency>  
<groupId>org.apache.tomcat.embed</groupId>  
<artifactId>tomcat-embed-websocket</artifactId>  
<version>8.5.23</version>  
<scope>compile</scope>  
</dependency>  
We can also use spring-mvc without using the embedded Tomcat server. If we want to do so, we need to exclude the Tomcat server by using the <exclusion> tag, as shown in the following code.

<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-web</artifactId>  
<exclusions>  
<exclusion>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-tomcat</artifactId>  
</exclusion>  
</exclusions>  
</dependency>  



Spring Data JPA
--------------------

handles most of the complexity of JDBC-based database access and ORM (Object Relational Mapping).
It makes the implementation of your persistence layer easier and faster.

Features
 1. No-code repository
 2. Reduced boilerplate code
 3. Generated Queries
      ex: 
	    public interface EmployeeRepository extends CrudRepository<Employee, Long>   
           {  
             Employee findByName(String name);  
           }  
		   
	  Employee is the entity that is to be managed, and Long is the data type of primary key.
	  Spring internally generates a JPQL (Java Persistence Query Language) query based on the method name.
	  
	  
Spring Data JPA provides three repositories are as follows:
 1.CrudRepository:
     standard create, read, update, and delete It contains method like findOne(), findAll(), save(), delete(), etc.
 2.PagingAndSortingRepository: 
     CrudRepository and adds the findAll methods. It allows us to sort and retrieve the data in a paginated way.
 3.JpaRepository:
     It is a JPA specific repository It is defined in Spring Data Jpa. It extends the both repository CrudRepository and PagingAndSortingRepository. 
	 It adds the JPA-specific methods, like flush() to trigger a flush on the persistence context.

dependancies
  1. 
  <dependency>  
<groupId>org.springframework.data</groupId>  
<artifactId>spring-data-jpa</artifactId>  
<version>2.2.3.RELEASE</version>  
</dependency>  	 
	
Spring Boot Starter Data JPA.
---------------------------------	
spring-boot-starter-data-jpa internally uses the spring-boot-jpa dependency (since Spring Boot version 1.5.3).

<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-data-jpa</artifactId>  
<version>2.2.2.RELEASE</version>  
</dependency>  
	 
	 
1. Entity Manager: Once we define the mapping, it handles all the interactions with the database.
2. PQL (Java Persistence Query Language): It provides a way to write queries to execute searches against entities. It is different from the SQL queries.
                                       JPQL queries already understand the mapping that is defined between entities. We can add additional conditions if required.	
3. Criteria API: It defines a Java-based API to execute searches against the database.

Hibernate vs. JPA:
--------------------
Hibernate is the implementation of JPA. It is the most popular ORM framework, while JPA is an API that defines the specification.
Hibernate understands the mapping that we add between objects and tables. 
It ensures that data is retrieved/ stored from the database based on the mapping. It also provides additional features on the top of the JPA.	

Spring Boot Starter Actuator
--------------------------------

Actuator brings production-ready features to our application.
features like,
    Monitoring our app
	gathering metrics
	understanding traffic
	understanding the state of our database
main benefit of this library is that we can get production-grade tools without having to actually implement these features ourselves.
expose operational information about the running application.It uses HTTP endpoints or JMX beans to enable us to interact with it.

spring-boot-actuator dependency
------------------------------
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>











Spring Boot Starter Test
Spring Boot DevTools
Spring Boot Multi-Module Project
Spring Boot Packaging
Spring Boot Auto-configuration
Project Deployment Using Tomcat
Spring Boot AOP
Spring Boot Database - crud
SB Caching
Spring Boot Change Port


















































